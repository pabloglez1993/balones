---
title: "Balones"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
date: "11/27/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Librerías:

```{r balones}
rm(list=ls())

library(readxl)
library(fastDummies)
library(brms)
```

Datos:

Debido a que los datos de Marca, Diseño son categóricos, los convertimos a dummies usando código de R.

```{r}
datos <- read_excel("datos_11_9_21_FG.xlsx")


# Librer?a fastDummies para convertir variables a dummy y quitar 1 categor?a de cada variable.
datos_dummy <- dummy_cols(datos,  select_columns = c("Marca", "Diseno"),remove_first_dummy = TRUE)

#Limpiar datos para quitar variables repetidas o que no se van a usar 
datos_dummy1 <- subset(datos_dummy,select=-c(RES,Marca,Diseno))

#Renombrar la primera columna
names(datos_dummy1)[1] <- "Y"

datos_dummy1 <- data.frame(datos_dummy1)
```

Modelo:

Regresión logística
Es un tipo de análisis de regresión utilizado para predecir la probabilidad de una variable categórica en función de variables predictoras. Este tipo de análisis se enmarca en el conjunto de Modelos lineales Generalizados usando una función de enlace logit. 

Con Optimización NelderMead
Es un método numérico para minimizar, en nuestro caso maximizar una función objetivo en un espacio multidimensional.  El método utiliza el concepto de un simplex, que es un politopo de N+1 vértices en N dimensiones: un segmento de línea en una línea, un triángulo en un plano, un tetraedro en un espacio tridimensional y así sucesivamente.

Dado que se conoce que la preferencia por Gaser < Molten < Voit

```{r}
# modelo bernoulli
fit <- brm(Y ~ Diseno_Del_mundial+
             Precio+
             Marca_Gaser+
             Diseno_Fondo_blanco+
             Marca_Molten+
             Marca_Voit +
             Diseno_Colorido+
             Diseno_Con_tematica,
           data = datos_dummy1, 
           family = bernoulli(link = "logit"), 
           silent=TRUE, 
           refresh = -1,
           prior = c(set_prior("normal(-1,1)", class="b", coef="Marca_Gaser"), 
                     set_prior("normal(1, 1)", class="b", coef="Marca_Voit"), 
                     set_prior("normal(0, 1)", class="b", coef="Marca_Molten") 
                    ), 
)

summary(fit)
```

Función:

```{r}

loss <- function(price){
  # First Create the input data to predict with out model - we want to predict whether or not our phone will sell
  our.ball <- data.frame(Diseno_Del_mundial=0,
                            Precio=price,
                            Marca_Gaser=1,
                            Diseno_Fondo_blanco=1,
                            Marca_Molten=0,
                            Marca_Voit=0,
                            Diseno_Colorido=0,
                            Diseno_Con_tematica=0
                            ) 
  
  # Next, for each posterior sample from out model, predict whether or not our phone would sell at the given price. This will give a vector of 0's and 1's, did the phone sell in each posterior sample. Think of each posterior sample as a simulation. 
  pp <- posterior_predict(fit, newdata=our.ball)
  
  # Next calculate the expected return for each of these posterior simulations
  mean(pp*price)
}

(op <- optim(100, function(x) -loss(x)))
```

Gráfica:

Los modelos bayesianos nos permiten incluir información previa.

Podemos actualizar el modelo después de una campaña promocional de Gaser.

Es viable replicar el modelo para otras configuraciones de balones para estimar el ingreso máximo experado.

```{r}
x <- 90:1200 # Listing prices to evaluate
l <- sapply(x, loss) 
plot(x, l, xlab = "Listing Price", ylab = "Expected Return")
```
